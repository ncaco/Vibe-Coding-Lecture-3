# Next.js 개발 규칙

## 프로젝트 구조 및 아키텍처

### 디렉토리 구조 표준화
```
src/
├── app/                    # App Router (Next.js 13+)
│   ├── (routes)/          # Route groups
│   ├── api/               # API routes
│   └── globals.css
├── components/            # 재사용 가능한 컴포넌트
│   ├── ui/               # 기본 UI 컴포넌트
│   ├── forms/            # 폼 관련 컴포넌트
│   ├── layout/           # 레이아웃 컴포넌트
│   └── business/         # 비즈니스 로직 컴포넌트
├── lib/                  # 유틸리티 함수
├── hooks/                # 커스텀 훅
├── types/                # TypeScript 타입 정의
├── constants/            # 상수 정의
└── styles/               # 스타일 관련 파일
```

## 컴포넌트 일반화 및 중앙화 규칙

### 1. 컴포넌트 설계 원칙

#### 재사용성 우선
- 모든 컴포넌트는 재사용 가능하도록 설계합니다.
- Props 인터페이스를 명확히 정의하고 문서화합니다.
- 기본값과 옵셔널 props를 적절히 활용합니다.

#### 단일 책임 원칙
- 각 컴포넌트는 하나의 명확한 책임만 가집니다.
- 복잡한 컴포넌트는 더 작은 단위로 분해합니다.
- 비즈니스 로직과 UI 로직을 분리합니다.

### 2. 컴포넌트 분류 및 구조

#### UI 컴포넌트 (components/ui/)
```typescript
// 기본 UI 컴포넌트는 최대한 순수하게 유지
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  className?: string;
}

// 기본값과 타입 안전성 보장
const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  children,
  onClick,
  disabled = false,
  className = '',
}) => {
  // 구현
};
```

#### 비즈니스 컴포넌트 (components/business/)
```typescript
// 비즈니스 로직을 포함하는 컴포넌트
interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (userId: string) => void;
}

// UI 컴포넌트를 조합하여 비즈니스 컴포넌트 구성
const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  return (
    <Card>
      <Avatar src={user.avatar} />
      <Typography variant="h6">{user.name}</Typography>
      <Button onClick={() => onEdit?.(user)}>편집</Button>
    </Card>
  );
};
```

### 3. 상태 관리 전략

#### 상태 관리 라이브러리 선택 가이드

**클라이언트 상태 (Zustand 권장)**
- UI 상태 (모달, 사이드바, 폼 상태)
- 사용자 설정 (테마, 언어, 선호도)
- 애플리케이션 설정
- 임시 데이터

**서버 상태 (TanStack Query 권장)**
- API 데이터 (사용자 정보, 제품 목록)
- 캐싱이 필요한 데이터
- 백그라운드 동기화
- 낙관적 업데이트

#### 클라이언트 상태 관리 (Zustand)
```typescript
// types/clientState.ts
interface ClientState {
  // UI 상태
  isSidebarOpen: boolean;
  activeModal: string | null;
  selectedItems: string[];
  
  // 사용자 설정
  theme: 'light' | 'dark';
  language: 'ko' | 'en';
  notifications: boolean;
  
  // 애플리케이션 상태
  currentStep: number;
  formData: Record<string, any>;
}

// lib/stores/clientStore.ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface ClientStore extends ClientState {
  // UI 액션
  toggleSidebar: () => void;
  openModal: (modalId: string) => void;
  closeModal: () => void;
  selectItem: (itemId: string) => void;
  
  // 설정 액션
  setTheme: (theme: 'light' | 'dark') => void;
  setLanguage: (language: 'ko' | 'en') => void;
  toggleNotifications: () => void;
  
  // 애플리케이션 액션
  setCurrentStep: (step: number) => void;
  updateFormData: (key: string, value: any) => void;
}

export const useClientStore = create<ClientStore>()(
  devtools(
    persist(
      (set, get) => ({
        // 초기 상태
        isSidebarOpen: false,
        activeModal: null,
        selectedItems: [],
        theme: 'light',
        language: 'ko',
        notifications: true,
        currentStep: 0,
        formData: {},
        
        // UI 액션
        toggleSidebar: () => set((state) => ({ 
          isSidebarOpen: !state.isSidebarOpen 
        })),
        openModal: (modalId) => set({ activeModal: modalId }),
        closeModal: () => set({ activeModal: null }),
        selectItem: (itemId) => set((state) => ({
          selectedItems: state.selectedItems.includes(itemId)
            ? state.selectedItems.filter(id => id !== itemId)
            : [...state.selectedItems, itemId]
        })),
        
        // 설정 액션
        setTheme: (theme) => set({ theme }),
        setLanguage: (language) => set({ language }),
        toggleNotifications: () => set((state) => ({ 
          notifications: !state.notifications 
        })),
        
        // 애플리케이션 액션
        setCurrentStep: (step) => set({ currentStep: step }),
        updateFormData: (key, value) => set((state) => ({
          formData: { ...state.formData, [key]: value }
        })),
      }),
      {
        name: 'client-storage',
        partialize: (state) => ({ 
          theme: state.theme, 
          language: state.language,
          notifications: state.notifications 
        }),
      }
    )
  )
);
```

#### 서버 상태 관리 (TanStack Query)
```typescript
// lib/query/client.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5분
      gcTime: 10 * 60 * 1000, // 10분
      retry: 3,
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
});

// hooks/queries/useUsers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';

export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

export function useUsers(filters?: UserFilters) {
  return useQuery({
    queryKey: userKeys.list(JSON.stringify(filters)),
    queryFn: () => apiClient.getUsers(filters),
    staleTime: 2 * 60 * 1000, // 2분
  });
}

export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => apiClient.getUser(id),
    enabled: !!id,
    staleTime: 5 * 60 * 1000, // 5분
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (userData: CreateUserData) => apiClient.createUser(userData),
    onSuccess: (newUser) => {
      // 낙관적 업데이트
      queryClient.setQueryData(userKeys.lists(), (old: User[] = []) => [
        ...old,
        newUser
      ]);
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
    onError: (error) => {
      console.error('사용자 생성 실패:', error);
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserData }) =>
      apiClient.updateUser(id, data),
    onMutate: async ({ id, data }) => {
      // 낙관적 업데이트
      await queryClient.cancelQueries({ queryKey: userKeys.detail(id) });
      const previousUser = queryClient.getQueryData(userKeys.detail(id));
      
      queryClient.setQueryData(userKeys.detail(id), (old: User) => ({
        ...old,
        ...data,
      }));
      
      return { previousUser };
    },
    onError: (err, { id }, context) => {
      // 에러 시 이전 상태로 롤백
      if (context?.previousUser) {
        queryClient.setQueryData(userKeys.detail(id), context.previousUser);
      }
    },
    onSettled: (data, error, { id }) => {
      // 성공/실패 관계없이 쿼리 무효화
      queryClient.invalidateQueries({ queryKey: userKeys.detail(id) });
    },
  });
}
```

#### 상태 관리 통합 사용 예시
```typescript
// components/UserProfile.tsx
import { useUser } from '@/hooks/queries/useUsers';
import { useClientStore } from '@/lib/stores/clientStore';

export function UserProfile({ userId }: { userId: string }) {
  // 서버 상태 (TanStack Query)
  const { data: user, isLoading, error } = useUser(userId);
  
  // 클라이언트 상태 (Zustand)
  const { theme, language, isSidebarOpen, toggleSidebar } = useClientStore();

  if (isLoading) return <UserProfileSkeleton />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div className={`theme-${theme}`}>
      <div className="flex items-center justify-between">
        <h1>{user.name}</h1>
        <button onClick={toggleSidebar}>
          {isSidebarOpen ? '닫기' : '열기'}
        </button>
      </div>
      <p>언어: {language}</p>
      <UserDetails user={user} />
    </div>
  );
}

// components/UserList.tsx
import { useUsers } from '@/hooks/queries/useUsers';
import { useClientStore } from '@/lib/stores/clientStore';

export function UserList() {
  // 서버 상태
  const { data: users, isLoading } = useUsers();
  
  // 클라이언트 상태
  const { selectedItems, selectItem, theme } = useClientStore();

  if (isLoading) return <UserListSkeleton />;

  return (
    <div className={`theme-${theme}`}>
      {users?.map((user) => (
        <UserCard
          key={user.id}
          user={user}
          isSelected={selectedItems.includes(user.id)}
          onSelect={() => selectItem(user.id)}
        />
      ))}
    </div>
  );
}
```

### 4. 컴포넌트 라이브러리 중앙화

#### 컴포넌트 인덱스 파일
```typescript
// components/ui/index.ts
export { Button } from './Button';
export { Input } from './Input';
export { Card } from './Card';
export { Typography } from './Typography';
export { Avatar } from './Avatar';

// components/index.ts
export * from './ui';
export * from './forms';
export * from './layout';
export * from './business';
```

#### 테마 및 스타일 중앙화 (Tailwind CSS 권장)
```typescript
// constants/theme.ts
export const theme = {
  colors: {
    primary: '#007bff',
    secondary: '#6c757d',
    success: '#28a745',
    error: '#dc3545',
  },
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '3rem',
  },
  breakpoints: {
    sm: '576px',
    md: '768px',
    lg: '992px',
    xl: '1200px',
  },
} as const;

// lib/utils/cn.ts - Tailwind CSS 클래스 병합 유틸리티
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

### 5. API 및 데이터 페칭 중앙화

#### API 클라이언트 중앙화 (TanStack Query 권장)
```typescript
// lib/api.ts
class ApiClient {
  private baseURL: string;
  
  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }
  
  async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    if (!response.ok) throw new Error('API 요청 실패');
    return response.json();
  }
  
  async post<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (!response.ok) throw new Error('API 요청 실패');
    return response.json();
  }
}

export const apiClient = new ApiClient(process.env.NEXT_PUBLIC_API_URL!);
```

#### TanStack Query를 활용한 데이터 페칭
```typescript
// lib/query/client.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5분
      gcTime: 10 * 60 * 1000, // 10분
      retry: 3,
      refetchOnWindowFocus: false,
    },
  },
});

// hooks/queries/useUsers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';

export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

export function useUsers(filters?: UserFilters) {
  return useQuery({
    queryKey: userKeys.list(JSON.stringify(filters)),
    queryFn: () => apiClient.getUsers(filters),
  });
}

export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => apiClient.getUser(id),
    enabled: !!id,
  });
}
```

### 6. 폼 관리 중앙화

#### 폼 유효성 검사 스키마 (React Hook Form + Zod 권장)
```typescript
// lib/validation/schemas.ts
import { z } from 'zod';

export const userSchema = z.object({
  name: z.string().min(2, '이름은 2자 이상이어야 합니다'),
  email: z.string().email('유효한 이메일을 입력해주세요'),
  age: z.number().min(18, '18세 이상이어야 합니다'),
});

export const loginSchema = z.object({
  email: z.string().email('유효한 이메일을 입력해주세요'),
  password: z.string().min(6, '비밀번호는 6자 이상이어야 합니다'),
});

// hooks/useFormWithValidation.ts
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

export function useFormWithValidation<T extends z.ZodType>(
  schema: T,
  defaultValues?: Partial<z.infer<T>>
) {
  return useForm<z.infer<T>>({
    resolver: zodResolver(schema),
    defaultValues,
    mode: 'onChange',
  });
}
```

### 7. 에러 처리 중앙화

#### 에러 바운더리
```typescript
// components/ErrorBoundary.tsx
import React from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends React.Component<
  React.PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />;
    }

    return this.props.children;
  }
}
```

### 8. 성능 최적화 규칙

#### 컴포넌트 메모이제이션
```typescript
// 무거운 컴포넌트는 React.memo 사용
const ExpensiveComponent = React.memo<Props>(({ data }) => {
  // 복잡한 렌더링 로직
  return <div>{/* 렌더링 결과 */}</div>;
});

// 커스텀 훅 메모이제이션
export function useMemoizedValue<T>(value: T, deps: any[]): T {
  return useMemo(() => value, deps);
}
```

#### 이미지 최적화
```typescript
// Next.js Image 컴포넌트 사용
import Image from 'next/image';

const OptimizedImage: React.FC<{ src: string; alt: string }> = ({ src, alt }) => (
  <Image
    src={src}
    alt={alt}
    width={500}
    height={300}
    placeholder="blur"
    blurDataURL="data:image/jpeg;base64,..."
  />
);
```

### 9. 테스트 규칙 (Jest + React Testing Library 권장)

#### 컴포넌트 테스트 구조
```typescript
// __tests__/components/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '@/components/ui/Button';

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
```

### 10. 페이지 및 라우트 관리

#### App Router 구조 설계
```typescript
// app/layout.tsx - 루트 레이아웃
import { Providers } from '@/components/Providers';
import { Header } from '@/components/layout/Header';
import { Footer } from '@/components/layout/Footer';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body>
        <Providers>
          <Header />
          <main className="min-h-screen">{children}</main>
          <Footer />
        </Providers>
      </body>
    </html>
  );
}

// app/page.tsx - 홈페이지
export default function HomePage() {
  return (
    <div className="container mx-auto px-4">
      <h1>홈페이지</h1>
    </div>
  );
}
```

#### 라우트 그룹 및 중첩 라우트
```typescript
// app/(auth)/layout.tsx - 인증 관련 레이아웃
export default function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8">
        {children}
      </div>
    </div>
  );
}

// app/(auth)/login/page.tsx
export default function LoginPage() {
  return (
    <div>
      <h2>로그인</h2>
      <LoginForm />
    </div>
  );
}

// app/(dashboard)/layout.tsx - 대시보드 레이아웃
import { Sidebar } from '@/components/layout/Sidebar';

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex">
      <Sidebar />
      <main className="flex-1 p-6">{children}</main>
    </div>
  );
}
```

#### 동적 라우트 및 매개변수
```typescript
// app/users/[id]/page.tsx - 동적 라우트
interface UserPageProps {
  params: {
    id: string;
  };
}

export default async function UserPage({ params }: UserPageProps) {
  const user = await getUser(params.id);
  
  if (!user) {
    notFound();
  }

  return (
    <div>
      <h1>{user.name}</h1>
      <UserProfile user={user} />
    </div>
  );
}

// app/products/[category]/[id]/page.tsx - 중첩 동적 라우트
interface ProductPageProps {
  params: {
    category: string;
    id: string;
  };
  searchParams: {
    color?: string;
    size?: string;
  };
}

export default async function ProductPage({ 
  params, 
  searchParams 
}: ProductPageProps) {
  const product = await getProduct(params.id);
  
  return (
    <div>
      <ProductDetails 
        product={product} 
        selectedColor={searchParams.color}
        selectedSize={searchParams.size}
      />
    </div>
  );
}
```

#### API 라우트 설계
```typescript
// app/api/users/route.ts - 사용자 API
import { NextRequest, NextResponse } from 'next/server';
import { userSchema } from '@/lib/validation';

export async function GET(request: NextRequest) {
  try {
    const users = await getUsers();
    return NextResponse.json(users);
  } catch (error) {
    return NextResponse.json(
      { error: '사용자 목록을 가져오는데 실패했습니다' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validatedData = userSchema.parse(body);
    
    const user = await createUser(validatedData);
    return NextResponse.json(user, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: '유효하지 않은 데이터입니다', details: error.errors },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: '사용자 생성에 실패했습니다' },
      { status: 500 }
    );
  }
}

// app/api/users/[id]/route.ts - 개별 사용자 API
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getUser(params.id);
    
    if (!user) {
      return NextResponse.json(
        { error: '사용자를 찾을 수 없습니다' },
        { status: 404 }
      );
    }
    
    return NextResponse.json(user);
  } catch (error) {
    return NextResponse.json(
      { error: '사용자 정보를 가져오는데 실패했습니다' },
      { status: 500 }
    );
  }
}
```

#### 라우트 미들웨어 및 보안
```typescript
// middleware.ts - 전역 미들웨어
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // 인증 체크
  const token = request.cookies.get('auth-token');
  const isAuthPage = request.nextUrl.pathname.startsWith('/login') || 
                     request.nextUrl.pathname.startsWith('/register');
  const isProtectedRoute = request.nextUrl.pathname.startsWith('/dashboard');

  if (isProtectedRoute && !token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  if (isAuthPage && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  // 로깅
  console.log(`${request.method} ${request.nextUrl.pathname}`);

  return NextResponse.next();
}

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/login',
    '/register',
    '/api/:path*',
  ],
};
```

#### 페이지 메타데이터 관리
```typescript
// app/layout.tsx - 기본 메타데이터
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: {
    default: 'My App',
    template: '%s | My App',
  },
  description: 'My App description',
  keywords: ['nextjs', 'react', 'typescript'],
  authors: [{ name: 'Your Name' }],
  creator: 'Your Name',
  openGraph: {
    type: 'website',
    locale: 'ko_KR',
    url: 'https://myapp.com',
    title: 'My App',
    description: 'My App description',
    siteName: 'My App',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'My App',
    description: 'My App description',
  },
};

// app/users/[id]/page.tsx - 동적 메타데이터
export async function generateMetadata({ 
  params 
}: { 
  params: { id: string } 
}): Promise<Metadata> {
  const user = await getUser(params.id);
  
  if (!user) {
    return {
      title: '사용자를 찾을 수 없습니다',
    };
  }

  return {
    title: `${user.name}의 프로필`,
    description: `${user.name}의 프로필 페이지입니다`,
    openGraph: {
      title: `${user.name}의 프로필`,
      description: `${user.name}의 프로필 페이지입니다`,
      images: [user.avatar],
    },
  };
}
```

#### 라우트 핸들러 및 에러 처리
```typescript
// app/error.tsx - 에러 페이지
'use client';

import { useEffect } from 'react';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error('Page error:', error);
  }, [error]);

  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-4">문제가 발생했습니다</h2>
        <p className="text-gray-600 mb-4">
          페이지를 로드하는 중 오류가 발생했습니다.
        </p>
        <button
          onClick={reset}
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
          다시 시도
        </button>
      </div>
    </div>
  );
}

// app/not-found.tsx - 404 페이지
import Link from 'next/link';

export default function NotFound() {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-4">페이지를 찾을 수 없습니다</h2>
        <p className="text-gray-600 mb-4">
          요청하신 페이지가 존재하지 않습니다.
        </p>
        <Link
          href="/"
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
          홈으로 돌아가기
        </Link>
      </div>
    </div>
  );
}
```

#### 라우트 유틸리티 및 헬퍼
```typescript
// lib/routes.ts - 라우트 상수 및 헬퍼
export const ROUTES = {
  HOME: '/',
  LOGIN: '/login',
  REGISTER: '/register',
  DASHBOARD: '/dashboard',
  USERS: '/users',
  PRODUCTS: '/products',
  SETTINGS: '/settings',
} as const;

export const createUserRoute = (id: string) => `/users/${id}`;
export const createProductRoute = (category: string, id: string) => 
  `/products/${category}/${id}`;

// lib/navigation.ts - 네비게이션 헬퍼
import { ROUTES } from './routes';

export const navigation = {
  main: [
    { name: '홈', href: ROUTES.HOME },
    { name: '사용자', href: ROUTES.USERS },
    { name: '제품', href: ROUTES.PRODUCTS },
  ],
  user: [
    { name: '대시보드', href: ROUTES.DASHBOARD },
    { name: '설정', href: ROUTES.SETTINGS },
  ],
} as const;
```

### 11. 라이브러리 사용 규칙

#### 상태 관리 라이브러리 (Zustand + TanStack Query 권장)

##### 클라이언트 상태 관리 (Zustand)
```typescript
// lib/stores/userStore.ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface UserState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  updateProfile: (data: Partial<User>) => Promise<void>;
}

export const useUserStore = create<UserState>()(
  devtools(
    persist(
      (set, get) => ({
        user: null,
        isLoading: false,
        error: null,
        
        login: async (credentials) => {
          set({ isLoading: true, error: null });
          try {
            const user = await loginApi(credentials);
            set({ user, isLoading: false });
          } catch (error) {
            set({ error: error.message, isLoading: false });
          }
        },
        
        logout: () => {
          set({ user: null, error: null });
        },
        
        updateProfile: async (data) => {
          const { user } = get();
          if (!user) return;
          
          set({ isLoading: true });
          try {
            const updatedUser = await updateProfileApi(user.id, data);
            set({ user: updatedUser, isLoading: false });
          } catch (error) {
            set({ error: error.message, isLoading: false });
          }
        },
      }),
      {
        name: 'user-storage',
        partialize: (state) => ({ user: state.user }),
      }
    )
  )
);
```

##### 서버 상태 관리 (TanStack Query)
```typescript
// hooks/queries/useUsers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';

export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

export function useUsers(filters?: UserFilters) {
  return useQuery({
    queryKey: userKeys.list(JSON.stringify(filters)),
    queryFn: () => apiClient.getUsers(filters),
    staleTime: 2 * 60 * 1000, // 2분
  });
}

export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => apiClient.getUser(id),
    enabled: !!id,
    staleTime: 5 * 60 * 1000, // 5분
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (userData: CreateUserData) => apiClient.createUser(userData),
    onSuccess: (newUser) => {
      // 낙관적 업데이트
      queryClient.setQueryData(userKeys.lists(), (old: User[] = []) => [
        ...old,
        newUser
      ]);
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

#### UI 라이브러리 (Tailwind CSS + Shadcn/ui 권장)

##### Tailwind CSS (스타일링)
```typescript
// lib/styles/tailwind.ts - 커스텀 설정
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          500: '#3b82f6',
          900: '#1e3a8a',
        },
      },
      spacing: {
        '18': '4.5rem',
        '88': '22rem',
      },
      animation: {
        'fade-in': 'fadeIn 0.5s ease-in-out',
        'slide-up': 'slideUp 0.3s ease-out',
      },
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ],
};

export default config;
```

##### Shadcn/ui (컴포넌트 라이브러리)
```typescript
// components/ui/button.tsx - Shadcn/ui 컴포넌트 확장
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };
```

#### 폼 관리 라이브러리 (React Hook Form + Zod 권장)
```typescript
// hooks/useFormWithValidation.ts
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

export function useFormWithValidation<T extends z.ZodType>(
  schema: T,
  defaultValues?: Partial<z.infer<T>>
) {
  return useForm<z.infer<T>>({
    resolver: zodResolver(schema),
    defaultValues,
    mode: 'onChange',
  });
}

// lib/validation/schemas.ts
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('유효한 이메일을 입력해주세요'),
  password: z.string().min(6, '비밀번호는 6자 이상이어야 합니다'),
  rememberMe: z.boolean().optional(),
});

export const userProfileSchema = z.object({
  name: z.string().min(2, '이름은 2자 이상이어야 합니다'),
  email: z.string().email('유효한 이메일을 입력해주세요'),
  bio: z.string().max(500, '자기소개는 500자 이하여야 합니다').optional(),
  avatar: z.string().url('유효한 URL을 입력해주세요').optional(),
});

// components/forms/LoginForm.tsx
import { useFormWithValidation } from '@/hooks/useFormWithValidation';
import { loginSchema } from '@/lib/validation/schemas';

export function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useFormWithValidation(loginSchema);

  const onSubmit = async (data: z.infer<typeof loginSchema>) => {
    try {
      await loginApi(data);
    } catch (error) {
      console.error('Login failed:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input {...register('email')} type="email" placeholder="이메일" />
        {errors.email && <span>{errors.email.message}</span>}
      </div>
      <div>
        <input {...register('password')} type="password" placeholder="비밀번호" />
        {errors.password && <span>{errors.password.message}</span>}
      </div>
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '로그인 중...' : '로그인'}
      </button>
    </form>
  );
}
```

#### 데이터 페칭 라이브러리 (TanStack Query 권장)
```typescript
// lib/query/client.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5분
      gcTime: 10 * 60 * 1000, // 10분
      retry: 3,
      refetchOnWindowFocus: false,
    },
  },
});

// hooks/queries/useUsers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';

export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

export function useUsers(filters?: UserFilters) {
  return useQuery({
    queryKey: userKeys.list(JSON.stringify(filters)),
    queryFn: () => apiClient.getUsers(filters),
  });
}

export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => apiClient.getUser(id),
    enabled: !!id,
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (userData: CreateUserData) => apiClient.createUser(userData),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserData }) =>
      apiClient.updateUser(id, data),
    onSuccess: (updatedUser) => {
      queryClient.setQueryData(userKeys.detail(updatedUser.id), updatedUser);
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

#### 유틸리티 라이브러리 (Lodash + Date-fns 권장)

##### Lodash (유틸리티)
```typescript
// lib/utils/lodash-helpers.ts
import { debounce, throttle, memoize } from 'lodash';

// 디바운스된 검색 함수
export const debouncedSearch = debounce((query: string) => {
  // 검색 로직
}, 300);

// 스크롤 이벤트 쓰로틀링
export const throttledScrollHandler = throttle((event: Event) => {
  // 스크롤 처리 로직
}, 100);

// 메모이제이션된 계산 함수
export const memoizedCalculation = memoize((input: number) => {
  // 복잡한 계산 로직
  return input * 2;
});

// lib/utils/array-helpers.ts
import { chunk, groupBy, uniq } from 'lodash';

export const arrayHelpers = {
  chunk: <T>(array: T[], size: number): T[][] => chunk(array, size),
  groupBy: <T>(array: T[], key: keyof T): Record<string, T[]> => groupBy(array, key),
  uniq: <T>(array: T[]): T[] => uniq(array),
};
```

##### Date-fns (날짜 처리)
```typescript
// lib/utils/date-helpers.ts
import { format, formatDistance, parseISO, isValid } from 'date-fns';
import { ko } from 'date-fns/locale';

export const dateHelpers = {
  // 날짜 포맷팅
  formatDate: (date: Date | string, formatStr: string = 'yyyy-MM-dd'): string => {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    return format(dateObj, formatStr, { locale: ko });
  },
  
  // 상대적 시간 표시
  formatRelativeTime: (date: Date | string): string => {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    return formatDistance(dateObj, new Date(), { addSuffix: true, locale: ko });
  },
  
  // 유효한 날짜인지 확인
  isValidDate: (date: any): boolean => {
    if (typeof date === 'string') {
      return isValid(parseISO(date));
    }
    return isValid(date);
  },
};
```

#### 애니메이션 라이브러리 (Framer Motion 권장)

##### Framer Motion
```typescript
// components/animations/FadeIn.tsx
import { motion } from 'framer-motion';

interface FadeInProps {
  children: React.ReactNode;
  delay?: number;
  duration?: number;
}

export function FadeIn({ children, delay = 0, duration = 0.5 }: FadeInProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration, delay }}
    >
      {children}
    </motion.div>
  );
}

// components/animations/PageTransition.tsx
import { motion } from 'framer-motion';

const pageVariants = {
  initial: {
    opacity: 0,
    x: -20,
  },
  in: {
    opacity: 1,
    x: 0,
  },
  out: {
    opacity: 0,
    x: 20,
  },
};

const pageTransition = {
  type: 'tween',
  ease: 'anticipate',
  duration: 0.5,
};

export function PageTransition({ children }: { children: React.ReactNode }) {
  return (
    <motion.div
      initial="initial"
      animate="in"
      exit="out"
      variants={pageVariants}
      transition={pageTransition}
    >
      {children}
    </motion.div>
  );
}
```

#### 로딩 상태 라이브러리 (React Skeleton 권장)

##### React Skeleton
```typescript
// components/ui/skeleton.tsx - 기본 스켈레톤 컴포넌트
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  );
}

export { Skeleton };

// components/skeletons/UserCardSkeleton.tsx - 사용자 카드 스켈레톤
import { Skeleton } from "@/components/ui/skeleton";

export function UserCardSkeleton() {
  return (
    <div className="rounded-lg border p-4 space-y-3">
      <div className="flex items-center space-x-3">
        <Skeleton className="h-12 w-12 rounded-full" />
        <div className="space-y-2">
          <Skeleton className="h-4 w-[200px]" />
          <Skeleton className="h-3 w-[150px]" />
        </div>
      </div>
      <Skeleton className="h-3 w-full" />
      <Skeleton className="h-3 w-3/4" />
    </div>
  );
}

// components/skeletons/ProductGridSkeleton.tsx - 제품 그리드 스켈레톤
export function ProductGridSkeleton({ count = 6 }: { count?: number }) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {Array.from({ length: count }).map((_, index) => (
        <div key={index} className="rounded-lg border p-4 space-y-3">
          <Skeleton className="h-48 w-full rounded-md" />
          <Skeleton className="h-4 w-3/4" />
          <Skeleton className="h-3 w-1/2" />
          <Skeleton className="h-8 w-full" />
        </div>
      ))}
    </div>
  );
}

// components/skeletons/TableSkeleton.tsx - 테이블 스켈레톤
export function TableSkeleton({ rows = 5 }: { rows?: number }) {
  return (
    <div className="space-y-3">
      {Array.from({ length: rows }).map((_, index) => (
        <div key={index} className="flex space-x-4">
          <Skeleton className="h-4 w-[100px]" />
          <Skeleton className="h-4 w-[200px]" />
          <Skeleton className="h-4 w-[150px]" />
          <Skeleton className="h-4 w-[100px]" />
        </div>
      ))}
    </div>
  );
}

// hooks/useSkeleton.ts - 스켈레톤 상태 관리 훅
import { useState, useEffect } from 'react';

export function useSkeleton(isLoading: boolean, delay: number = 300) {
  const [showSkeleton, setShowSkeleton] = useState(false);

  useEffect(() => {
    if (isLoading) {
      const timer = setTimeout(() => {
        setShowSkeleton(true);
      }, delay);
      return () => clearTimeout(timer);
    } else {
      setShowSkeleton(false);
    }
  }, [isLoading, delay]);

  return showSkeleton;
}

// components/withSkeleton.tsx - 스켈레톤 HOC
import React from 'react';

interface WithSkeletonProps {
  isLoading: boolean;
  skeleton: React.ComponentType<any>;
  delay?: number;
}

export function withSkeleton<P extends object>(
  Component: React.ComponentType<P>,
  SkeletonComponent: React.ComponentType<any>
) {
  return function WithSkeletonComponent({
    isLoading,
    delay = 300,
    ...props
  }: P & WithSkeletonProps) {
    const showSkeleton = useSkeleton(isLoading, delay);

    if (showSkeleton) {
      return <SkeletonComponent />;
    }

    return <Component {...(props as P)} />;
  };
}

// 사용 예시: components/UserCard.tsx
import { withSkeleton } from '@/components/withSkeleton';
import { UserCardSkeleton } from '@/components/skeletons/UserCardSkeleton';

interface UserCardProps {
  user: User;
}

function UserCard({ user }: UserCardProps) {
  return (
    <div className="rounded-lg border p-4">
      <div className="flex items-center space-x-3">
        <img src={user.avatar} alt={user.name} className="h-12 w-12 rounded-full" />
        <div>
          <h3 className="font-medium">{user.name}</h3>
          <p className="text-sm text-gray-500">{user.email}</p>
        </div>
      </div>
    </div>
  );
}

export const UserCardWithSkeleton = withSkeleton(UserCard, UserCardSkeleton);

// TanStack Query와 함께 사용
export function UserList() {
  const { data: users, isLoading } = useUsers();

  if (isLoading) {
    return <UserCardSkeleton />;
  }

  return (
    <div className="space-y-4">
      {users?.map((user) => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}
```

#### 테스트 라이브러리 (Jest + React Testing Library 권장)
```typescript
// __tests__/components/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '@/components/ui/Button';

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});

// __tests__/hooks/useUser.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useUser } from '@/hooks/queries/useUser';

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });
  
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

describe('useUser', () => {
  it('fetches user data', async () => {
    const { result } = renderHook(() => useUser('123'), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual({
      id: '123',
      name: 'Test User',
      email: 'test@example.com',
    });
  });
});
```

#### 라이브러리 버전 관리 및 권장사항

##### package.json 의존성 관리
```json
{
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^4.4.0",
    "@tanstack/react-query": "^5.0.0",
    "react-hook-form": "^7.48.0",
    "@hookform/resolvers": "^3.3.0",
    "zod": "^3.22.0",
    "framer-motion": "^10.16.0",
    "date-fns": "^2.30.0",
    "lodash": "^4.17.21",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0",
    "react-skeleton": "^1.0.0"
  },
  "devDependencies": {
    "@types/lodash": "^4.14.200",
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.1.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "tailwindcss": "^3.3.0",
    "@tailwindcss/forms": "^0.5.0",
    "@tailwindcss/typography": "^0.5.0"
  }
}
```

##### 라이브러리 선택 가이드라인

**상태 관리**: Zustand (클라이언트 상태) + TanStack Query (서버 상태)
**데이터 페칭**: TanStack Query (서버 상태 관리와 통합)
**폼 관리**: React Hook Form + Zod
**스타일링**: Tailwind CSS + Shadcn/ui
**애니메이션**: Framer Motion
**로딩 상태**: React Skeleton (Tailwind CSS 기반)
**테스트**: Jest + React Testing Library
**유틸리티**: Lodash + Date-fns

### 12. 환경 설정 중앙화

#### 환경 변수 관리
```typescript
// lib/config.ts
export const config = {
  api: {
    baseUrl: process.env.NEXT_PUBLIC_API_URL!,
    timeout: 5000,
  },
  app: {
    name: process.env.NEXT_PUBLIC_APP_NAME || 'My App',
    version: process.env.NEXT_PUBLIC_APP_VERSION || '1.0.0',
  },
  features: {
    enableAnalytics: process.env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true',
    enableDebug: process.env.NODE_ENV === 'development',
  },
} as const;
```

이러한 규칙들을 통해 Next.js 프로젝트에서 컴포넌트의 재사용성, 유지보수성, 그리고 일관성을 보장할 수 있습니다.
alwaysApply: false
---
